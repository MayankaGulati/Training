STRINGS-


An example of string-
	‘more than one characters between inverted commas is a string ’
substitution of variables in string -
	“the string #{variable_name}”
	example-
	var = 8
	puts “the variable is #{var}”


string build in methods-

example-

#!/usr/bin/ruby

myStr = String.new("THIS IS TEST")
foo = myStr.downcase

puts "#{foo}"
output-
this is test


PUBLIC class methods -

New string:
3.0.1 :001 > s=String.new
 => "" 
3.0.1 :002 > s.encoding
 => #<Encoding:ASCII-8BIT> 

3.0.1 :003 > s=String.new("bewiuf9  894nc74#d5}[g ")
 => "bewiuf9  894nc74#d5}[g " 
3.0.1 :004 > s.encoding
 => #<Encoding:UTF-8> 

3.0.1 :005 > s=String.new(encoding: 'ASCII')
 => "" 
3.0.1 :006 > s.encoding
 => #<Encoding:US-ASCII> 

3.0.1 :007 > s=String.new('foo', encoding: 'ASCII')
 => "foo" 
3.0.1 :008 > s.encoding
 => #<Encoding:US-ASCII> 

3.0.1 :009 > s0=String.new('foo',encoding: 'ASCII')
 => "foo" 
3.0.1 :010 > s1='foo'.force_encoding('ASCII')
 => "foo" 
3.0.1 :011 > s0.encoding==s1.encoding
 => true 

capacity:
3.0.1 :012 > String.new(capacity: 1)
 => "" 
3.0.1 :013 > String.new(capacity: 100)
 => "" 

3.0.1 :014 > s.encoding
 => #<Encoding:US-ASCII> 
3.0.1 :015 > String.new('hello',encoding: 'UTF-8', capacity:25 )
 => "hello" 


SELF-

3.0.1 :013 > self
 => main 
3.0.1 :014 > self.class
 => Object 

PUBLIC instance method-

string%object :

3.0.1 :001 > "%05d" %123
 => "00123" 
3.0.1 :002 > "%09d" %123
 => "000000123" 
3.0.1 :003 > "%05s: %016x " % ["ID" , self.object_id]
 => "   ID: 0000000000000104 " 
3.0.1 :004 > "foo = %{foo}" % {foo: 'bar'}
 => "foo = bar" 
3.0.1 :005 > "foo = %{foo} , baz = %{baz}" % {foo: 'bar' , baz:'bat'}
 => "foo = bar , baz = bat" 

string * integer :

3.0.1 :008 > "HO!" * 6
 => "HO!HO!HO!HO!HO!HO!" 
3.0.1 :009 > "HO!" * 0
 => "" 

string + another string :

3.0.1 :011 > "hello from " + self.to_s
 => "hello from main" 

3.0.1 :016 > "hey there " + "good morning!"
 => "hey there good morning!" 


string<< object :

3.0.1 :019 > s="foo"
 => "foo" 
3.0.1 :020 > s<< 'bar'
 => "foobar" 
3.0.1 :021 > s
 => "foobar" 

Comparing two strings-

using <=> :

3.0.1 :001 > 'foo' <=> 'foo'
 => 0 
3.0.1 :002 > 'foo' <=> 'food'
 => -1 
3.0.1 :003 > 'food' <=> 'foo'
 => 1 
3.0.1 :004 > 'food' <=> 'FOO'
 => 1 
3.0.1 :005 > 'foo' <=> 'FOO'
 => 1 
3.0.1 :006 > 'FOOD' <=> 'food'
 => -1 
3.0.1 :007 > 'FOOD' <=> '1'
 => 1 
3.0.1 :008 > 'FOOD' <=> 1
 => nil

using == :

3.0.1 :009 > s = 'food'
 => "food" 
3.0.1 :010 > s=='FOOD'
 => false 
3.0.1 :011 > s=='foo'
 => false 
3.0.1 :012 > s=='food'
 => true  

using =~  :

it’ll display the position of the character.

3.0.1 :001 > 'foo' =~ /f/
 => 0 
3.0.1 :002 > 'foo' =~ /o/
 => 1 
3.0.1 :003 > 'foo' =~ /m/
 => nil


to display string’s char from index value-

3.0.1 :004 > 'food'[3]
 => "d" 
3.0.1 :005 > 'Mayanka'[5]
 => "k" 
3.0.1 :006 > 'Mayanka'[8]
 => nil 
3.0.1 :007 > 'Mayanka'[-2]
 => "k" 
3.0.1 :008 > 'Mayanka'[-8]
 => nil 

to display string’s char from index value and length 

3.0.1 :009 > 'Mayanka'[4,3]
 => "nka" 
3.0.1 :010 > 'Mayanka'[-2,3]
 => "ka" 
3.0.1 :011 > 'Mayanka'[-5,3]
 => "yan" 
3.0.1 :012 > 'Mayanka'[1,7]
 => "ayanka"
3.0.1 :014 > 'Mayanka'[-4,0]
 => "" 
3.0.1 :015 > 'Mayanka'[3,-1]
 => nil

.bytesize method -

it’ll display the size of the string.

3.0.1 :002 > "Mayanka".bytesize
 => 7 
3.0.1 :003 > "food".bytesize
 => 4 

.byteslice method- 

it’ll display the index value from the string and the range if given.

3.0.1 :004 > "Mayanka".byteslice(3)
 => "a" 
3.0.1 :005 > s='Mayanka'
 => "Mayanka" 
3.0.1 :006 > s.byteslice(3)
 => "a" 
3.0.1 :007 > s.byteslice(3,7)
 => "anka" 
3.0.1 :008 > s.byteslice(0,3)
 => "May" 


.encoding method-

3.0.1 :016 > s.encoding
 => #<Encoding:UTF-8> 
3.0.1 :017 > s.byteslice(5).encoding
 => #<Encoding:UTF-8> 
3.0.1 :018 > s.bytesize.encoding

.capitalize method & .capitalize!

capitalize nethod will change the first char in capital and rest in downcase.
.capitalize! Will do the capitalize method changes and if it dosen’t change anything it returns nil.

3.0.1 :022 > 'mayanka gulati'.capitalize!
 => "Mayanka gulati" 
3.0.1 :023 > 'mayanka gulati'.capitalize
 => "Mayanka gulati" 
3.0.1 :024 > 'mayanka GULATI'.capitalize
 => "Mayanka gulati" 
3.0.1 :025 > 'mayanka GULATI'.capitalize!
 => "Mayanka gulati" 
3.0.1 :026 > 'Mayanka gulati'.capitalize!
 => nil 


.casecmp method -
it comapares self.downcase and otherstring.downcase

    1. -1 if other_string.downcase is larger.
    2. 0 if the two are equal.
    3. 1 if other_string.downcase is smaller.
    4. nil if the two are incomparable.

3.0.1 :027 > 'mayanka'.casecmp('mayanka')
 => 0 
3.0.1 :028 > 'mayanka'.casecmp('Mayanka')
 => 0 
3.0.1 :029 > 'mayanka'.casecmp('MAYANKA')
 => 0 
3.0.1 :030 > 'MAYANKA'.casecmp('mayanka')
 => 0 
3.0.1 :031 > 'MAYANKA'.casecmp('mayan')
 => 1 
3.0.1 :032 > 'maya'.casecmp('mayanka')
 => -1 


.casecmp? Method-

3.0.1 :033 > 'mayanka'.casecmp?('mayanka')
 => true 
3.0.1 :034 > 'mayanka'.casecmp?('Mayanka')
 => true 
3.0.1 :035 > 'mayanka'.casecmp?('MAYANKA')
 => true 
3.0.1 :036 > 'maya'.casecmp?('mayanka')
 => false 
3.0.1 :037 > 'MAYANKA'.casecmp?('mayan')
 => false  

.center method-

it’ll take space of the index provided with string in the middle

3.0.1 :039 > 'mayanka'.center(5)
 => "mayanka" 
3.0.1 :040 > 'mayanka'.center(10)
 => " mayanka  " 
3.0.1 :041 > 'mayanka'.center(20)
 => "      mayanka       " 
3.0.1 :086 > "mayanka".center(20,'0')
 => "000000mayanka0000000" 


.chomp method-

3.0.1 :061 > "mayanka".chomp
 => "mayanka" 
3.0.1 :062 > "mayanka\n\r".chomp
 => "mayanka\n" 
3.0.1 :063 > "mayanka\r\n".chomp
 => "mayanka" 
3.0.1 :064 > "mayanka\n".chomp
 => "mayanka" 
3.0.1 :065 > "mayanka\r".chomp
 => "mayanka" 
3.0.1 :066 > "mayanka".chomp('ka')
 => "mayan" 
3.0.1 :067 > "mayanka\n\r\n\r".chomp('')
 => "mayanka\n\r\n\r" 
3.0.1 :068 > "mayanka\r\n\r\n".chomp('')
 => "mayanka" 
3.0.1 :069 > "mayanka \n gulati".chomp
 => "mayanka \n gulati" 
3.0.1 :070 > "mayanka \r gulati".chomp
 => "mayanka \r gulati" 
3.0.1 :071 > "mayanka \r\n gulati".chomp
 => "mayanka \r\n gulati" 


.chomp! Method-
3.0.1 :073 > "mayanka".chomp!
 => nil 
3.0.1 :074 > "mayanka\n".chomp!
 => "mayanka" 


.chop method-

3.0.1 :077 > "mayanka".chop
 => "mayank" 
3.0.1 :078 > "mayanka\n".chop
 => "mayanka" 
3.0.1 :079 > "mayanka\r".chop
 => "mayanka" 
3.0.1 :080 > "mayanka\r\n".chop
 => "mayanka" 
3.0.1 :081 > "mayanka\n\r".chop
 => "mayanka\n" 
3.0.1 :082 > "mayanka".chop.chop
 => "mayan" 


.chr method-

3.0.1 :089 > "mayanka".chr
 => "m" 

.clear method-

3.0.1 :090 > "mayanka".clear
 => "" 

.concat method-

3.0.1 :091 > "mayanka".concat("gulati")
 => "mayankagulati" 
3.0.1 :093 > 'mayanka'.concat(32,'gulati')
 => "mayanka gulati" 
3.0.1 :097 > s="mayanka"
 => "mayanka" 
3.0.1 :098 > s.concat(32,"gulati")
 => "mayanka gulati" 


.count method-

3.0.1 :100 > "mayanka".count "a"
 => 3 
3.0.1 :101 > "mayanka".count "aeiou"
 => 3 
3.0.1 :102 > "mayanka gulati".count "aeiou"
 => 6 
3.0.1 :105 > "mayanka gulati".count "ka" "a" 
 => 5 
3.0.1 :106 > "mayanka^gulati".count "ka" 
 => 5 


 
